const colors = require('colors');

module.exports.generate = (reportedRecords, mapping, options) => {
    if (!options) {
        options = {};
    }
    if (!options.colored) {
        colors.disable();
    } else {
        colors.enable();
    }
    var reportBody = '';
    if (!Array.isArray(reportedRecords)) {
        reportedRecords = [reportedRecords];
    }

    var columnWidths = new Array(mapping.length);
    for (let i in mapping) {
        if (!columnWidths[i]) {
            columnWidths[i] = 0;
        }
        if (mapping[i].name.length > columnWidths[i]) {
            columnWidths[i] = mapping[i].name.length;
        }
        for (let rec of reportedRecords) {
            if (!rec[mapping[i].value]) {
                continue;
            }
            rec[mapping[i].value] = `${rec[mapping[i].value]}`.replace(/\n/g, ' ');
            if (rec[mapping[i].value] && rec[mapping[i].value].length > columnWidths[i]) {
                if (mapping[i].max && rec[mapping[i].value].length > mapping[i].max) {
                    columnWidths[i] = mapping[i].max;
                    var lineParts = [];
                    for (let k = 0; k < Math.ceil(rec[mapping[i].value].length / columnWidths[i]); k++) {
                        lineParts.push(rec[mapping[i].value].substr(k * columnWidths[i], columnWidths[i]));
                    }
                    rec[mapping[i].value] = lineParts;
                } else {
                    columnWidths[i] = rec[mapping[i].value].length;
                }
            }
        }
    }

    var topLine = '';
    for (let i in columnWidths) {
        topLine += (topLine ? '┬' : '┌') + '─'.repeat(columnWidths[i]);
    }
    topLine += '┐';
    reportBody += topLine + '\n';

    var header = '│';
    for (let i in mapping) {
        header += mapping[i].name.padEnd(columnWidths[i]).green + '│';
    }
    reportBody += header + '\n';

    for (let i in reportedRecords) {
        if (!options.compact || i == 0) {
            var midLine = '';
            for (let j in columnWidths) {
                midLine += (midLine ? '┼' : '├') + '─'.repeat(columnWidths[j]);
            }
            midLine += '┤';

            reportBody += midLine + '\n';
        }

        var maxPartsCount = 1;
        for (let j in mapping) {
            if (
                Array.isArray(reportedRecords[i][mapping[j].value]) &&
                reportedRecords[i][mapping[j].value].length > maxPartsCount
            ) {
                maxPartsCount = reportedRecords[i][mapping[j].value].length;
            }
        }

        for (let k = 0; k < maxPartsCount; k++) {
            var midLine = '│'
            for (let j in mapping) {
                if (Array.isArray(reportedRecords[i][mapping[j].value])) {
                    midLine += (isNaN(parseInt(reportedRecords[i][mapping[j].value][k]))
                        ? reportedRecords[i][mapping[j].value][k].padEnd(columnWidths[j])
                        : reportedRecords[i][mapping[j].value][k].padStart(columnWidths[j])
                    ).yellow;
                } else if (reportedRecords[i][mapping[j].value] && k == 0) {
                    midLine += (isNaN(parseInt(reportedRecords[i][mapping[j].value]))
                        ? reportedRecords[i][mapping[j].value].padEnd(columnWidths[j])
                        : reportedRecords[i][mapping[j].value].padStart(columnWidths[j])
                    ).yellow;
                } else {
                    midLine += ' '.repeat(columnWidths[j]);
                }
                midLine += '│';
            }
            reportBody += midLine + '\n';
        }
    }

    var bottomLine = '';
    for (let i in columnWidths) {
        bottomLine += (bottomLine ? '┴' : '└') + '─'.repeat(columnWidths[i]);
    }
    bottomLine += '┘';
    reportBody += bottomLine;

    if (options.print) {
        console.log(reportBody);
    } else {
        return reportBody;
    }
}